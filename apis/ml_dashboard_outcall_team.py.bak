import falcon, json
from mintloan_utils import DB, generate, validate, utils, datetime, timedelta
from dateutil.relativedelta import relativedelta
from pypika import Query, Table, functions

class DashboardOutcallResource:

    def on_get(self, req, resp):
        """Handles GET requests"""
        
        try:
            raw_json = req.stream.read()
        except Exception as ex:
            raise falcon.HTTPError(falcon.HTTP_400,'Error', ex.message) 

    def on_post(self, req, resp):
        """Handles POST requests"""
        output_dict = {"data":{"firstPriority": 0, "secondPriority":0, "thirdPriority":0, "fourthPriority": 0, "todaysTasks":0,
                               "pendingTasks":0, "upcomingTasks":0}, "msgHeader":{"authToken" : ""} }
        errors = utils.errors
        success = ""
        try:
            raw_json = req.stream.read()
            input_dict = json.loads(raw_json, encoding='utf-8')
        except Exception as ex:
            raise #falcon.HTTPError(falcon.HTTP_400,'Invalid JSON', 'The JSON was incorrect.')
        try:
            if False:#not validate.Request(api='dashboard', request=input_dict):
                output_dict["data"].update({"error":1, "message":errors["json"]})
                resp.body = json.dumps(output_dict)
            else:
                db = DB(input_dict["msgHeader"]["authLoginID"])#, filename='mysql-slave.config')
                dbw = DB(input_dict["msgHeader"]["authLoginID"])
                val_error = validate(db).basicChecks(token=input_dict["msgHeader"]["authToken"], loginID = input_dict["msgHeader"]["authLoginID"], 
                                                  checkLogin=True)
                if val_error:
                    output_dict["data"].update({"error":1, "message":val_error})
                    resp.body = json.dumps(output_dict)
                else:
                    custcred = Table("mw_customer_login_credentials", schema="mint_loan")
                    emis = Table("mw_client_loan_emi_details", schema="mint_loan")
                    tasks = Table("mw_task_lists", schema="mint_loan_admin")
                    kycdocs = Table("mw_cust_kyc_documents", schema="mint_loan")
                    log = Table("mw_customer_change_log", schema="mint_loan")
                    profile = Table("mw_client_profile", schema="mint_loan")
                    calldata = Table("mw_call_data", schema="mint_loan")
                    days_2 = (datetime.now() - timedelta(days=2)).strftime("%Y-%m-%d 00:00:00")
                    days_7 = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d 00:00:00")
                    days_31 = (datetime.now() - timedelta(days=31)).strftime("%Y-%m-%d 00:00:00")
                    today = datetime.now().strftime("%Y-%m-%d 00:00:00")
                    callback = Query.from_(calldata).select("CUSTOMER_ID").distinct().where((calldata.CALLBACK_DATETIME>today) | (calldata.CREATED_DATE>today))
                    cities = {"BAN":['Bangalore rural', 'bangalore kasavanalli', 'Bangalore', 'banglore', 'BAN', 'bangaloor', 'Bangalore ',
                                     'Bamgalore'], "PUNE":['PUNE', 'punr'], "CHENNAI":["Chennai"]}
                    if "city" in input_dict["data"]:
                        if input_dict["data"]["city"] in ("BAN", "PUNE", "CHENNAI"):
                            Q = Query.from_(profile).select("CUSTOMER_ID").where(profile.CURRENT_CITY.isin(cities[input_dict["data"]["city"]]))
                            Q = Q.where(profile.CUSTOMER_ID.notin(callback))
                        elif input_dict["data"]["city"]=="MUM":
                            Q = Query.from_(profile).select("CUSTOMER_ID").where(profile.CURRENT_CITY.notin(sum(cities.values(), [])))
                            Q = Q.where(profile.CUSTOMER_ID.notin(callback))
                        else:
                            Q = Query.from_(profile).select("CUSTOMER_ID").distinct().where(profile.CUSTOMER_ID.notin(callback))
                    else:
                        Q = Query.from_(profile).select("CUSTOMER_ID").distinct().where(profile.CUSTOMER_ID.notin(callback))
                    q1 = Query.from_(kycdocs).select("CUSTOMER_ID").distinct().where((kycdocs.CREATED_DATE>days_2) & 
                                                                                     (kycdocs.VERIFICATION_STATUS.isnull()))
                    qc = Query.from_(custcred).select(functions.Count(custcred.CUSTOMER_ID).distinct().as_("c")).where(custcred.CUSTOMER_ID.isin(Q))
                    fdata = db.runQuery(qc.where((custcred.CUSTOMER_ID.notin(q1)) & (custcred.STAGE=="AWAITING_ADDITIONAL_DOCS")))["data"]#[0]["c"]
                    q = Query.from_(emis).select(functions.Count(emis.CUSTOMER_ID).distinct().as_("c")).where(emis.CUSTOMER_ID.isin(Q))
                    sdata = db.runQuery(q.where((emis.DUE_DATE<days_31) & (emis.OVERDUE_AMOUNT>0)))["data"][0]["c"]
		    #print db.pikastr(qc.where((custcred.CUSTOMER_ID.notin(q1)) & (custcred.STAGE=="AWAITING_ADDITIONAL_DOCS")))
                    tdata = db.runQuery(q.where((emis.DUE_DATE<days_7) & (emis.DUE_DATE>days_31) & (emis.OVERDUE_AMOUNT>0)))["data"][0]["c"]
                    frdata = db.runQuery(qc.where((custcred.STAGE=='AWAITING_LOAN_APPLICATION')))["data"][0]["c"]
		    #print db.pikastr(qc.where((custcred.STAGE=='AWAITING_LOAN_APPLICATION')))
                    q=Query.from_(tasks).select(functions.Count(tasks.star).as_('C')).where(tasks.LOGIN_ID==input_dict["msgHeader"]["authLoginID"])
                    q1 = q.where((tasks.TASK_DATETIME>=int(datetime.now().date().strftime("%s"))) & (tasks.STATUS.notin(["COMPLETED", "CANCEL"]) &
                                (tasks.TASK_DATETIME<int((datetime.now()+timedelta(days=1)).date().strftime("%s")))))
                    tTasks = db.runQuery(q1.orderby(tasks.TASK_DATETIME))["data"]
                    tTasks = tTasks[0]["C"] if tTasks else 0
                    yTasks = db.runQuery(q.where((tasks.TASK_DATETIME<int(datetime.now().date().strftime("%s"))) &
                                                 (tasks.STATUS.notin(["COMPLETED", "CANCEL"]))).orderby(tasks.TASK_DATETIME))
                    yTasks = yTasks["data"][0]["C"] if yTasks["data"] else 0
                    uTasks = db.runQuery(q.where((tasks.TASK_DATETIME>int(datetime.now().date().strftime("%s"))) &
                                                 (tasks.STATUS.notin(["COMPLETED", "CANCEL"]))).orderby(tasks.TASK_DATETIME))
                    uTasks = uTasks["data"][0]["C"] if uTasks["data"] else 0
                    token = generate(dbw).AuthToken()
                    if token["updated"]:
                        output_dict["data"].update({"firstPriority": fdata, "secondPriority":sdata, "thirdPriority":tdata, 
                                                    "fourthPriority": frdata, "todaysTasks":tTasks,
                                                    "pendingTasks":yTasks, "upcomingTasks":uTasks})
                        output_dict["data"].update({"error":0, "message":success})
                        output_dict["msgHeader"]["authToken"] = token["token"]
                    else:
                        output_dict["data"].update({"error":1, "message":errors["token"]})
                resp.body = json.dumps(output_dict)
                db._DbClose_()
                dbw._DbClose_()
        except Exception as ex:
            raise #falcon.HTTPError(falcon.HTTP_400,'Invalid JSON', 'The JSON was incorrect.')


